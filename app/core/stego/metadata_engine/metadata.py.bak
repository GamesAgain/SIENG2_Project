import sys
import os
import json
import shutil
from io import BytesIO

# GUI Framework
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QListWidget, QTabWidget, QFormLayout, QLineEdit, QTextEdit,
                             QPushButton, QLabel, QFileDialog, QMessageBox, QTableWidget,
                             QTableWidgetItem, QHeaderView, QSplitter, QGroupBox, QStackedWidget, QFrame, QComboBox)
from PyQt6.QtCore import Qt, QByteArray
from PyQt6.QtGui import QIcon, QPixmap, QImage

# Logic Libraries
from PIL import Image, PngImagePlugin
import piexif
# import piexif.helper # ‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÅ‡∏•‡πâ‡∏ß ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÄ‡∏£‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Header ‡πÄ‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏ß‡∏£‡πå
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TCOP, COMM, TDRC, TALB, TRCK, TCON, TCOM, TPOS, TSSE, TXXX, APIC

# ==========================================
# PART 0: STYLING (DARK MODE)
# ==========================================
DARK_STYLE = """
QMainWindow, QDialog {
    background-color: #2b2b2b;
    color: #e0e0e0;
    font-family: 'Segoe UI', sans-serif;
    font-size: 10pt;
}
QWidget {
    color: #e0e0e0;
}
QGroupBox {
    border: 1px solid #555;
    border-radius: 5px;
    margin-top: 10px;
    font-weight: bold;
    color: #bbb;
}
QGroupBox::title {
    subcontrol-origin: margin;
    subcontrol-position: top left;
    padding: 0 5px;
}
QLineEdit, QTextEdit, QListWidget, QComboBox, QTableWidget {
    background-color: #3c3f41;
    border: 1px solid #555;
    border-radius: 4px;
    color: #fff;
    padding: 5px;
}
QLineEdit:focus, QTextEdit:focus {
    border: 1px solid #3daee9;
}
QHeaderView::section {
    background-color: #333;
    color: #fff;
    padding: 4px;
    border: 1px solid #555;
}
QPushButton {
    background-color: #3c3f41;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 6px 12px;
    color: #fff;
}
QPushButton:hover {
    background-color: #444;
    border: 1px solid #3daee9;
}
QTabBar::tab {
    background: #1e1e1e;
    color: #777;
    padding: 8px 20px;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
    border: 1px solid #333;
}
QTabBar::tab:selected {
    background: #444444;
    color: #fff;
    border-top: 2px solid #3daee9;
}
QMessageBox {
    background-color: #2b2b2b;
    color: #fff;
}
"""

# ==========================================
# PART 1: LOGIC HANDLER (BACKEND)
# ==========================================
class MetadataHandler:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå ‡πÅ‡∏¢‡∏Å‡∏à‡∏≤‡∏Å GUI"""

    @staticmethod
    def get_file_type(filepath):
        ext = os.path.splitext(filepath)[1].lower()
        if ext in ['.jpg', '.jpeg']: return 'JPEG'
        if ext == '.png': return 'PNG'
        if ext == '.mp3': return 'MP3'
        return None

    @staticmethod
    def _decode_bytes(b_data):
        """
        ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏à‡∏â‡∏£‡∏¥‡∏¢‡∏∞‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏ö‡∏ï‡πå (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏î‡∏≤‡∏ß/Mojibake)
        ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á Header ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô EXIF ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏≤ Encoding
        """
        if not b_data: return ""
        
        # 1. ‡∏•‡∏≠‡∏á‡∏ñ‡∏≠‡∏î‡∏ï‡∏≤‡∏° Header ‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô EXIF
        if b_data.startswith(b'UNICODE\x00'):
            try: return b_data[8:].decode('utf-16').rstrip('\x00')
            except: pass
        elif b_data.startswith(b'ASCII\x00\x00\x00'):
            try: return b_data[8:].decode('utf-8').rstrip('\x00')
            except: pass
            
        # 2. ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ Header ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á Brute-force ‡∏´‡∏•‡∏≤‡∏¢‡πÜ ‡πÅ‡∏ö‡∏ö
        decoders = ['utf-8', 'utf-16', 'utf-16-le', 'utf-16-be', 'cp1252']
        for enc in decoders:
            try:
                # ‡∏•‡∏≠‡∏á‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™
                val = b_data.decode(enc).rstrip('\x00')
                # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏î‡∏π‡∏ß‡πà‡∏≤‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏≤‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô JSON ‡πÑ‡∏´‡∏° (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡πâ‡∏ß‡∏¢ { ‡πÅ‡∏•‡∏∞‡∏à‡∏ö‡∏î‡πâ‡∏ß‡∏¢ })
                if val.strip().startswith('{') and val.strip().endswith('}'):
                    return val
                # ‡∏´‡∏£‡∏∑‡∏≠‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô UTF-8 ‡πÅ‡∏•‡∏∞‡∏≠‡πà‡∏≤‡∏ô‡∏£‡∏π‡πâ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Å‡πá‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏•‡∏¢
                if enc == 'utf-8': 
                    return val
            except:
                continue
        
        # Fallback: ‡∏ñ‡πâ‡∏≤‡∏à‡∏ô‡∏õ‡∏±‡∏ç‡∏ç‡∏≤‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÉ‡∏´‡πâ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÅ‡∏ö‡∏ö ignore errors
        try: return b_data.decode('utf-8', errors='ignore')
        except: return str(b_data)

    @staticmethod
    def read_metadata(filepath):
        ftype = MetadataHandler.get_file_type(filepath)
        data = {
            "type": ftype,
            "common": {"title": "", "artist": "", "copyright": "", "date": "", "software": "", "comment": ""},
            "specific": {},
            "custom": [],
            "cover_art": None
        }

        try:
            if ftype == 'JPEG':
                img = Image.open(filepath)
                try:
                    exif_dict = piexif.load(img.info.get('exif', b''))
                except:
                    exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}

                def get_str(d, key):
                    val = d.get(key, b'')
                    if isinstance(val, bytes):
                        # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏ä‡πà‡∏ß‡∏¢‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™
                        return MetadataHandler._decode_bytes(val)
                    return str(val)

                data["common"]["title"] = get_str(exif_dict["0th"], piexif.ImageIFD.ImageDescription)
                data["common"]["artist"] = get_str(exif_dict["0th"], piexif.ImageIFD.Artist)
                data["common"]["copyright"] = get_str(exif_dict["0th"], piexif.ImageIFD.Copyright)
                data["common"]["software"] = get_str(exif_dict["0th"], piexif.ImageIFD.Software)
                data["common"]["date"] = get_str(exif_dict["0th"], piexif.ImageIFD.DateTime)

                # Specific
                data["specific"]["Camera Model"] = get_str(exif_dict["0th"], piexif.ImageIFD.Model)
                data["specific"]["ISO Speed"] = str(exif_dict["Exif"].get(piexif.ExifIFD.ISOSpeedRatings, ""))
                
                # Rational helper
                def get_rational(d, key):
                    val = d.get(key)
                    if isinstance(val, tuple) and len(val) == 2:
                        return f"{val[0]}/{val[1]}" if val[1] != 0 else str(val[0])
                    return str(val) if val else ""

                data["specific"]["Shutter Speed"] = get_rational(exif_dict["Exif"], piexif.ExifIFD.ExposureTime)
                data["specific"]["F-Number"] = get_rational(exif_dict["Exif"], piexif.ExifIFD.FNumber)
                data["specific"]["GPS Latitude"] = "Present" if piexif.GPSIFD.GPSLatitude in exif_dict.get("GPS", {}) else ""

                # --- Custom Tag Handling via UserComment JSON ---
                raw_comment = exif_dict["Exif"].get(piexif.ExifIFD.UserComment, b'')
                comment_str = MetadataHandler._decode_bytes(raw_comment)
                
                try:
                    # ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡∏´‡∏≤ JSON structure
                    if "custom_tags" in comment_str:
                        # ‡∏´‡∏≤‡∏õ‡∏µ‡∏Å‡∏Å‡∏≤‡πÄ‡∏õ‡∏¥‡∏î‡∏õ‡∏¥‡∏î ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏≠‡∏á‡∏Ç‡∏¢‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏ï‡∏¥‡∏î‡∏°‡∏≤
                        start = comment_str.find('{')
                        end = comment_str.rfind('}') + 1
                        if start != -1 and end != -1:
                            clean_json = comment_str[start:end]
                            json_obj = json.loads(clean_json)
                            
                            if "real_comment" in json_obj:
                                data["common"]["comment"] = json_obj["real_comment"]
                            if "custom_tags" in json_obj:
                                for k, v in json_obj["custom_tags"].items():
                                    data["custom"].append((k, str(v)))
                        else:
                             data["common"]["comment"] = comment_str
                    else:
                        data["common"]["comment"] = comment_str
                except:
                    # ‡∏ñ‡πâ‡∏≤ Parse JSON ‡∏û‡∏±‡∏á ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô Text ‡∏ò‡∏£‡∏£‡∏°‡∏î‡∏≤
                    data["common"]["comment"] = comment_str

            elif ftype == 'PNG':
                img = Image.open(filepath)
                info = img.info
                
                data["common"]["title"] = info.get("Title", "")
                data["common"]["artist"] = info.get("Author", "")
                data["common"]["copyright"] = info.get("Copyright", "")
                data["common"]["software"] = info.get("Software", "")
                data["common"]["date"] = info.get("Creation Time", "")
                data["common"]["comment"] = info.get("Description", "") or info.get("Comment", "")

                data["specific"]["Gamma"] = str(info.get("gamma", ""))
                data["specific"]["DPI"] = str(info.get("dpi", ""))
                data["specific"]["Bit Depth"] = str(img.mode)

                exclude = ["Title", "Author", "Copyright", "Software", "Creation Time", "Description", "Comment", "interlace", "gamma", "dpi", "transparency", "aspect", "exif", "icc_profile"]
                for k, v in info.items():
                    if k not in exclude:
                        data["custom"].append((k, str(v)))

            elif ftype == 'MP3':
                audio = ID3(filepath)
                
                def get_id3(key): return str(audio.get(key, ""))
                
                data["common"]["title"] = get_id3("TIT2")
                data["common"]["artist"] = get_id3("TPE1")
                data["common"]["copyright"] = get_id3("TCOP")
                data["common"]["date"] = get_id3("TDRC")
                data["common"]["software"] = get_id3("TSSE")
                
                comm = audio.get("COMM::eng") or audio.get("COMM")
                data["common"]["comment"] = comm.text[0] if comm else ""

                data["specific"]["Album Name"] = get_id3("TALB")
                data["specific"]["Track Number"] = get_id3("TRCK")
                data["specific"]["Genre"] = get_id3("TCON")
                data["specific"]["Composer"] = get_id3("TCOM")
                data["specific"]["Disc Number"] = get_id3("TPOS")

                apic = audio.get("APIC:")
                if apic:
                    data["cover_art"] = apic.data

                for frame in audio.getall("TXXX"):
                    data["custom"].append((frame.desc, frame.text[0]))

        except Exception as e:
            print(f"Read Error: {e}")
        
        return data

    @staticmethod
    def save_metadata(filepath, data):
        ftype = MetadataHandler.get_file_type(filepath)
        try:
            if ftype == 'JPEG':
                img = Image.open(filepath)
                try:
                    exif_dict = piexif.load(img.info.get('exif', b''))
                except:
                    exif_dict = {"0th": {}, "Exif": {}, "GPS": {}, "1st": {}, "thumbnail": None}

                def to_bytes(s): return s.encode('utf-8') if s else b""

                exif_dict["0th"][piexif.ImageIFD.ImageDescription] = to_bytes(data["common"]["title"])
                exif_dict["0th"][piexif.ImageIFD.Artist] = to_bytes(data["common"]["artist"])
                exif_dict["0th"][piexif.ImageIFD.Copyright] = to_bytes(data["common"]["copyright"])
                exif_dict["0th"][piexif.ImageIFD.Software] = to_bytes(data["common"]["software"])
                if data["common"]["date"]:
                    exif_dict["0th"][piexif.ImageIFD.DateTime] = to_bytes(data["common"]["date"])

                # --- Save Custom Tags via JSON in UserComment ---
                custom_dict = {k: v for k, v in data["custom"]}
                
                # Logic: ‡∏™‡∏£‡πâ‡∏≤‡∏á JSON ‡πÄ‡∏™‡∏°‡∏≠‡∏ñ‡πâ‡∏≤‡∏°‡∏µ custom tags ‡∏´‡∏£‡∏∑‡∏≠ comment
                # ‡πÉ‡∏ä‡πâ ensure_ascii=False ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡πâ‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô \uXXXX
                if custom_dict:
                    payload = {
                        "real_comment": data["common"]["comment"],
                        "custom_tags": custom_dict
                    }
                    json_str = json.dumps(payload, ensure_ascii=False)
                else:
                    # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ custom tag ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏Ñ‡πà comment (‡πÅ‡∏ï‡πà‡πÉ‡∏™‡πà‡πÉ‡∏ô JSON structure ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠ ‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∞‡πÉ‡∏™‡πà plain text ‡∏Å‡πá‡πÑ‡∏î‡πâ)
                    # ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏á‡πà‡∏≤‡∏¢ ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ custom tag ‡πÄ‡∏£‡∏≤‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å comment ‡∏ï‡∏£‡∏á‡πÜ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡∏≠‡∏∑‡πà‡∏ô‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢
                    json_str = data["common"]["comment"]

                # ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Header ‡πÅ‡∏ö‡∏ö Manual (‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
                header = b'UNICODE\x00'
                # ‡∏ï‡πâ‡∏≠‡∏á encode ‡πÄ‡∏õ‡πá‡∏ô utf-16le ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö EXIF Unicode
                body = json_str.encode('utf-16le')
                user_comment = header + body
                
                exif_dict["Exif"][piexif.ExifIFD.UserComment] = user_comment
                
                exif_bytes = piexif.dump(exif_dict)
                img.save(filepath, exif=exif_bytes)

            elif ftype == 'PNG':
                img = Image.open(filepath)
                metadata = PngImagePlugin.PngInfo()

                if data["common"]["title"]: metadata.add_text("Title", data["common"]["title"])
                if data["common"]["artist"]: metadata.add_text("Author", data["common"]["artist"])
                if data["common"]["copyright"]: metadata.add_text("Copyright", data["common"]["copyright"])
                if data["common"]["software"]: metadata.add_text("Software", data["common"]["software"])
                if data["common"]["comment"]: metadata.add_text("Description", data["common"]["comment"])
                
                for k, v in data["custom"]:
                    metadata.add_text(k, v)

                img.save(filepath, pnginfo=metadata)

            elif ftype == 'MP3':
                audio = ID3(filepath)
                audio.add(TIT2(encoding=3, text=data["common"]["title"]))
                audio.add(TPE1(encoding=3, text=data["common"]["artist"]))
                audio.add(TCOP(encoding=3, text=data["common"]["copyright"]))
                audio.add(TDRC(encoding=3, text=data["common"]["date"]))
                audio.add(TSSE(encoding=3, text=data["common"]["software"]))
                audio.add(COMM(encoding=3, lang='eng', desc='', text=data["common"]["comment"]))
                
                s_data = data["specific"]
                if s_data.get("Album Name"): audio.add(TALB(encoding=3, text=s_data["Album Name"]))
                if s_data.get("Track Number"): audio.add(TRCK(encoding=3, text=s_data["Track Number"]))
                if s_data.get("Genre"): audio.add(TCON(encoding=3, text=s_data["Genre"]))
                if s_data.get("Composer"): audio.add(TCOM(encoding=3, text=s_data["Composer"]))
                if s_data.get("Disc Number"): audio.add(TPOS(encoding=3, text=s_data["Disc Number"]))

                # Cover Art Updating
                if "cover_art_data" in data and data["cover_art_data"] is not None:
                    audio.add(APIC(
                        encoding=3, # 3 is UTF-8
                        mime='image/jpeg', # Defaulting to jpeg, but works generally
                        type=3, # 3 is front cover
                        desc=u'Cover',
                        data=data["cover_art_data"]
                    ))

                # Custom (TXXX)
                audio.delall("TXXX")
                for k, v in data["custom"]:
                    audio.add(TXXX(encoding=3, desc=k, text=v))
                
                audio.save()

            return True, "Saved Successfully"
        except Exception as e:
            import traceback
            traceback.print_exc()
            return False, str(e)

# ==========================================
# PART 2: GUI (FRONTEND)
# ==========================================
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Metadata Master Pro (Python/PyQt6)")
        self.resize(1100, 750)
        self.setStyleSheet(DARK_STYLE)

        self.current_file = None
        self.current_data = None
        self.pending_cover_art = None # Store binary data of new cover
        self.widgets_specific_refs = {} 

        self.setup_ui()

    def setup_ui(self):
        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QHBoxLayout(main_widget)

        splitter = QSplitter(Qt.Orientation.Horizontal)

        # --- Left Panel ---
        left_panel = QGroupBox(" File Manager ")
        left_layout = QVBoxLayout()
        self.file_list = QListWidget()
        self.file_list.itemClicked.connect(self.load_file_to_editor)
        
        btn_add = QPushButton(" (+) Add Files ")
        btn_add.setStyleSheet("background-color: #0078d4; color: white; font-weight: bold;")
        btn_add.clicked.connect(self.action_add_files)
        
        btn_clear = QPushButton(" Clear List ")
        btn_clear.clicked.connect(lambda: self.file_list.clear())

        left_layout.addWidget(btn_add)
        left_layout.addWidget(self.file_list)
        left_layout.addWidget(btn_clear)
        left_panel.setLayout(left_layout)

        # --- Right Panel ---
        right_panel = QGroupBox(" Metadata Editor ")
        right_layout = QVBoxLayout()

        self.tabs = QTabWidget()
        self.tab_general = self.setup_general_tab()
        self.tab_specific = self.setup_specific_tab()
        self.tab_custom = self.setup_custom_tab()
        
        self.tabs.addTab(self.tab_general, "General Info")
        self.tabs.addTab(self.tab_specific, "Specific")
        self.tabs.addTab(self.tab_custom, "Custom Tags")

        right_layout.addWidget(self.tabs)

        self.btn_save = QPushButton(" SAVE METADATA ")
        self.btn_save.setStyleSheet("background-color: #2E7D32; color: white; font-weight: bold; font-size: 16px; padding: 12px;")
        self.btn_save.clicked.connect(self.save_current_file)
        
        right_layout.addWidget(self.btn_save)
        right_panel.setLayout(right_layout)

        splitter.addWidget(left_panel)
        splitter.addWidget(right_panel)
        splitter.setStretchFactor(1, 2)
        main_layout.addWidget(splitter)

    def setup_general_tab(self):
        widget = QWidget()
        layout = QVBoxLayout()
        form_layout = QFormLayout()
        form_layout.setLabelAlignment(Qt.AlignmentFlag.AlignRight)
        
        self.txt_title = QLineEdit()
        self.txt_artist = QLineEdit()
        self.txt_copyright = QLineEdit()
        self.txt_date = QLineEdit()
        self.txt_software = QLineEdit()
        self.txt_date.setPlaceholderText("YYYY:MM:DD HH:MM:SS")
        
        form_layout.addRow("Title:", self.txt_title)
        form_layout.addRow("Artist:", self.txt_artist)
        form_layout.addRow("Copyright:", self.txt_copyright)
        form_layout.addRow("Date Created:", self.txt_date)
        form_layout.addRow("Software:", self.txt_software)
        layout.addLayout(form_layout)

        layout.addWidget(QLabel("Description / Comment:"))
        self.txt_comment = QTextEdit()
        self.txt_comment.setMaximumHeight(100)
        layout.addWidget(self.txt_comment)
        layout.addStretch()
        widget.setLayout(layout)
        return widget

    def setup_specific_tab(self):
        container = QWidget()
        layout = QVBoxLayout()
        self.stack_specific = QStackedWidget()
        
        self.widgets_jpeg = self.create_jpeg_page()
        self.widgets_mp3 = self.create_mp3_page()
        self.widgets_png = self.create_png_page()
        
        self.stack_specific.addWidget(QLabel("Select a file to view specific details."))
        self.stack_specific.addWidget(self.widgets_jpeg['page_widget'])
        self.stack_specific.addWidget(self.widgets_mp3['page_widget'])
        self.stack_specific.addWidget(self.widgets_png['page_widget'])
        
        layout.addWidget(self.stack_specific)
        container.setLayout(layout)
        return container

    def create_jpeg_page(self):
        page = QWidget()
        form = QFormLayout()
        widgets = {'page_widget': page}
        
        # Read Only
        for field in ["Camera Model", "ISO Speed", "Shutter Speed", "F-Number"]:
            inp = QLineEdit()
            inp.setReadOnly(True)
            inp.setStyleSheet("color: #888; background: #252525;")
            form.addRow(field + ":", inp)
            widgets[field] = inp

        line = QFrame()
        line.setFrameShape(QFrame.Shape.HLine)
        form.addRow(line)

        # Writable
        for field in ["GPS Latitude", "GPS Longitude"]:
            inp = QLineEdit()
            form.addRow(field + ":", inp)
            widgets[field] = inp
            
        page.setLayout(form)
        return widgets

    def create_mp3_page(self):
        page = QWidget()
        layout = QVBoxLayout()
        form = QFormLayout()
        widgets = {'page_widget': page}

        # Cover Art
        self.lbl_cover_art = QLabel("No Cover Art")
        self.lbl_cover_art.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_cover_art.setFixedSize(150, 150)
        self.lbl_cover_art.setStyleSheet("border: 1px dashed #555; background-color: #1e1e1e;")
        
        btn_change_cover = QPushButton("Change Cover Art...")
        btn_change_cover.clicked.connect(self.change_cover_art)
        
        cover_box = QHBoxLayout()
        cover_box.addStretch()
        cover_box.addWidget(self.lbl_cover_art)
        cover_box.addWidget(btn_change_cover)
        cover_box.addStretch()
        layout.addLayout(cover_box)

        # Fields
        for field in ["Album Name", "Track Number", "Genre", "Composer", "Disc Number"]:
            inp = QLineEdit()
            form.addRow(field + ":", inp)
            widgets[field] = inp
            
        layout.addLayout(form)
        layout.addStretch()
        page.setLayout(layout)
        return widgets

    def create_png_page(self):
        page = QWidget()
        form = QFormLayout()
        widgets = {'page_widget': page}
        
        for field in ["Gamma", "Physical Size (DPI)", "Bit Depth"]:
            inp = QLineEdit()
            inp.setReadOnly(True)
            inp.setStyleSheet("color: #888; background: #252525;")
            form.addRow(field + ":", inp)
            widgets[field] = inp
            
        page.setLayout(form)
        return widgets

    def setup_custom_tab(self):
        widget = QWidget()
        layout = QVBoxLayout()

        self.table_custom = QTableWidget(0, 2)
        self.table_custom.setHorizontalHeaderLabels(["Tag Name (Key)", "Value"])
        self.table_custom.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        self.table_custom.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.table_custom.setAlternatingRowColors(True)
        
        layout.addWidget(self.table_custom)

        btn_layout = QHBoxLayout()
        btn_add = QPushButton(" (+) Add New Tag ")
        btn_add.setStyleSheet("background-color: #2E7D32;")
        btn_add.clicked.connect(self.action_add_row)
        
        btn_remove = QPushButton(" (-) Remove Selected ")
        btn_remove.setStyleSheet("background-color: #C62828;")
        btn_remove.clicked.connect(self.action_remove_row)
        
        btn_layout.addWidget(btn_add)
        btn_layout.addWidget(btn_remove)
        layout.addLayout(btn_layout)
        
        widget.setLayout(layout)
        return widget

    def action_add_row(self):
        row = self.table_custom.rowCount()
        self.table_custom.insertRow(row)
        self.table_custom.setItem(row, 0, QTableWidgetItem("NewKey"))
        self.table_custom.setItem(row, 1, QTableWidgetItem(""))

    def action_remove_row(self):
        row = self.table_custom.currentRow()
        if row >= 0: self.table_custom.removeRow(row)

    def action_add_files(self):
        files, _ = QFileDialog.getOpenFileNames(self, "Select Files", "", "Media (*.jpg *.jpeg *.png *.mp3)")
        for f in files:
            ftype = MetadataHandler.get_file_type(f)
            icon = "üéµ" if ftype == 'MP3' else "üñºÔ∏è"
            self.file_list.addItem(f"{icon} {f}")

    def load_file_to_editor(self, item):
        try:
            # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏ì‡∏µ item ‡πÄ‡∏õ‡πá‡∏ô None
            if not item: return

            filepath = item.text()[2:].strip()
            self.current_file = filepath
            self.pending_cover_art = None # Reset pending cover
            
            # Read Data
            self.current_data = MetadataHandler.read_metadata(filepath)
            
            # 1. General Tab
            c = self.current_data["common"]
            self.txt_title.setText(c["title"])
            self.txt_artist.setText(c["artist"])
            self.txt_copyright.setText(c["copyright"])
            self.txt_date.setText(c["date"])
            self.txt_software.setText(c["software"])
            self.txt_comment.setText(c["comment"])

            # 2. Specific Tab
            ftype = self.current_data["type"]
            s_data = self.current_data["specific"]
            
            if ftype == 'JPEG':
                self.stack_specific.setCurrentIndex(1)
                widgets = self.widgets_jpeg
            elif ftype == 'MP3':
                self.stack_specific.setCurrentIndex(2)
                widgets = self.widgets_mp3
                # Cover Art
                if self.current_data.get("cover_art"):
                    pix = QPixmap()
                    pix.loadFromData(self.current_data["cover_art"])
                    self.lbl_cover_art.setPixmap(pix.scaled(150, 150, Qt.AspectRatioMode.KeepAspectRatio))
                else:
                    self.lbl_cover_art.setText("No Cover Art")
            elif ftype == 'PNG':
                self.stack_specific.setCurrentIndex(3)
                widgets = self.widgets_png
            
            # ‡πÄ‡∏ï‡∏¥‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡∏á Widget (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà)
            if ftype in ['JPEG', 'MP3', 'PNG']:
                for k, val in s_data.items():
                    if k in widgets and isinstance(widgets[k], QLineEdit):
                        widgets[k].setText(val)

            # 3. Custom Tab
            self.table_custom.setRowCount(0)
            for k, v in self.current_data["custom"]:
                r = self.table_custom.rowCount()
                self.table_custom.insertRow(r)
                self.table_custom.setItem(r, 0, QTableWidgetItem(str(k)))
                self.table_custom.setItem(r, 1, QTableWidgetItem(str(v)))

        except Exception as e:
            print(f"UI Load Error: {e}")

    def change_cover_art(self):
        file, _ = QFileDialog.getOpenFileName(self, "Select Cover Image", "", "Images (*.jpg *.png)")
        if file:
            with open(file, 'rb') as f:
                self.pending_cover_art = f.read()
            
            pix = QPixmap(file)
            self.lbl_cover_art.setPixmap(pix.scaled(150, 150, Qt.AspectRatioMode.KeepAspectRatio))

    def save_current_file(self):
        if not self.current_file: return

        save_data = {
            "common": {
                "title": self.txt_title.text(),
                "artist": self.txt_artist.text(),
                "copyright": self.txt_copyright.text(),
                "date": self.txt_date.text(),
                "software": self.txt_software.text(),
                "comment": self.txt_comment.toPlainText()
            },
            "specific": {},
            "custom": []
        }

        # Specific
        ftype = self.current_data["type"]
        widgets = {}
        if ftype == 'JPEG': widgets = self.widgets_jpeg
        elif ftype == 'MP3': widgets = self.widgets_mp3
        
        for k, w in widgets.items():
            if isinstance(w, QLineEdit) and not w.isReadOnly():
                save_data["specific"][k] = w.text()

        # Cover Art Update (MP3)
        if ftype == 'MP3' and self.pending_cover_art:
            save_data["cover_art_data"] = self.pending_cover_art

        # Custom
        for r in range(self.table_custom.rowCount()):
            k = self.table_custom.item(r, 0).text()
            v = self.table_custom.item(r, 1).text()
            if k: save_data["custom"].append((k, v))

        success, msg = MetadataHandler.save_metadata(self.current_file, save_data)
        
        if success:
            QMessageBox.information(self, "Success", f"Metadata Saved Successfully!\n{os.path.basename(self.current_file)}")
            # Refresh data to ensure UI matches file
            current_item = self.file_list.currentItem()
            if current_item:
                self.load_file_to_editor(current_item)
        else:
            QMessageBox.critical(self, "Error", msg)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())